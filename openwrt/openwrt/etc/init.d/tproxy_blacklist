#!/bin/sh /etc/rc.common
# singbox-tproxy - Blacklist Mode (Production Perfect)

START=99
STOP=10
USE_PROCD=1

# --- Configuration ---
PROXY_PORT=7893
ROUTING_MARK=666
PROXY_FWMARK=0x1
TABLE_ID=100
LAN_IF="br-lan"           # Auto-detect if empty
DEBUG=0

# 【黑名单配置】
# 这些设备将【不走代理】（直连），其他设备默认走代理
# 格式：空格分隔 IP
BYPASS_SOURCES="10.0.0.176"

# 额外的目的地址旁路
EXTRA_BYPASS=""
# --- End Configuration ---

log() {
    logger -t singbox-tproxy "$@"
    [ "$DEBUG" -eq 1 ] && printf '%s\n' "$@" >&2
}

service_triggers() {
    procd_add_reload_trigger "firewall"
    procd_add_interface_trigger "interface.*" "lan" "$initscript" reload
}

load_modules() {
    modprobe nf_tproxy_ipv4 >/dev/null 2>&1
    modprobe nf_tproxy_ipv6 >/dev/null 2>&1
}

load_nft_rules() {
    NFT_TABLE="inet fw4"
    CHAIN_PRE="singbox_prerouting"
    CHAIN_OUT="singbox_output"

    log "Initializing rules (Blacklist Mode)..."

    # 1. Setup Chains
    nft add table $NFT_TABLE 2>/dev/null || true
    nft list chain $NFT_TABLE $CHAIN_PRE >/dev/null 2>&1 || nft add chain $NFT_TABLE $CHAIN_PRE
    nft flush chain $NFT_TABLE $CHAIN_PRE
    nft list chain $NFT_TABLE $CHAIN_OUT >/dev/null 2>&1 || nft add chain $NFT_TABLE $CHAIN_OUT
    nft flush chain $NFT_TABLE $CHAIN_OUT

    # 2. Setup Hooks
    if nft list chain $NFT_TABLE mangle_prerouting >/dev/null 2>&1; then
        nft list chain $NFT_TABLE mangle_prerouting | grep -q "jump $CHAIN_PRE" || \
            nft insert rule $NFT_TABLE mangle_prerouting jump $CHAIN_PRE comment "Singbox_Pre_Hook"
    else
        nft add chain $NFT_TABLE mangle_prerouting { type filter hook prerouting priority -150 \; } 2>/dev/null
        nft insert rule $NFT_TABLE mangle_prerouting jump $CHAIN_PRE comment "Singbox_Pre_Hook"
    fi

    if nft list chain $NFT_TABLE mangle_output >/dev/null 2>&1; then
        nft list chain $NFT_TABLE mangle_output | grep -q "jump $CHAIN_OUT" || \
            nft insert rule $NFT_TABLE mangle_output jump $CHAIN_OUT comment "Singbox_Out_Hook"
    else
        nft add chain $NFT_TABLE mangle_output { type filter hook output priority -150 \; } 2>/dev/null
        nft insert rule $NFT_TABLE mangle_output jump $CHAIN_OUT comment "Singbox_Out_Hook"
    fi

    # 3. Direct Rules (Bypass)
    nft add rule $NFT_TABLE $CHAIN_PRE udp dport { 67, 68 } return comment "Bypass_DHCP"
    nft add rule $NFT_TABLE $CHAIN_PRE ip6 nexthdr icmpv6 return comment "Bypass_IPv6_ICMP"
    [ -n "$LAN_IF" ] && nft add rule $NFT_TABLE $CHAIN_PRE fib daddr oifname "$LAN_IF" return comment "Bypass_PD_LAN_Traffic"
    nft add rule $NFT_TABLE $CHAIN_PRE ct status dnat return comment "Bypass_DNAT"

# ============================================================
    # 4. Source IP Bypass (优先放行直连设备) - 【已修复：自动识别 v4/v6】
    # ============================================================
    if [ -n "$BYPASS_SOURCES" ]; then
        CLEAN_IP=$(echo "$BYPASS_SOURCES" | tr -d '\r' | tr -s '[:space:]' ' ')
        for ip in $CLEAN_IP; do
            if echo "$ip" | grep -q ':'; then
                # 如果包含冒号，视为 IPv6
                nft add rule $NFT_TABLE $CHAIN_PRE ip6 saddr "$ip" return comment "Bypass_Src_Device_v6"
            else
                # 否则视为 IPv4
                nft add rule $NFT_TABLE $CHAIN_PRE ip saddr "$ip" return comment "Bypass_Src_Device_v4"
            fi
        done
    fi
    
    # 5. Local Bypass (本机流量)
    nft add rule $NFT_TABLE $CHAIN_PRE fib daddr type local return comment "Bypass_Local"
    
    # Private Addresses
    nft add rule $NFT_TABLE $CHAIN_PRE ip daddr { 127.0.0.0/8, 10.0.0.0/8, 172.16.0.0/12, 192.168.0.0/16, 224.0.0.0/4 } return
    nft add rule $NFT_TABLE $CHAIN_PRE ip6 daddr { ::1/128, fc00::/7, fe80::/10, ff00::/8, ::ffff:0:0/96 } return

    if [ -n "$EXTRA_BYPASS" ]; then
        for p in $EXTRA_BYPASS; do
            nft add rule $NFT_TABLE $CHAIN_PRE ip daddr $p return
        done
    fi

    # ============================================================
    # 6. Global TProxy (剩余流量全部劫持) - 【修复：语法拆分】
    # ============================================================
    # IPv4
    nft add rule $NFT_TABLE $CHAIN_PRE meta l4proto { tcp, udp } meta mark set $PROXY_FWMARK tproxy ip to :$PROXY_PORT accept comment "Proxy_All_IPv4" 2>/dev/null || \
    nft add rule $NFT_TABLE $CHAIN_PRE meta l4proto { tcp, udp } meta mark set $PROXY_FWMARK tproxy to :$PROXY_PORT accept 

    # IPv6
    nft add rule $NFT_TABLE $CHAIN_PRE meta l4proto { tcp, udp } meta mark set $PROXY_FWMARK tproxy ip6 to :$PROXY_PORT accept comment "Proxy_All_IPv6" 2>/dev/null || true

    # 7. Output Rules (Localhost)
    nft add rule $NFT_TABLE $CHAIN_OUT meta oifname "lo" return
    
    # 【修复：明确防死循环】
    nft add rule $NFT_TABLE $CHAIN_OUT meta mark $ROUTING_MARK return comment "Bypass_Singbox_Self"

    nft add rule $NFT_TABLE $CHAIN_OUT ip daddr { 127.0.0.0/8, 10.0.0.0/8, 172.16.0.0/12, 192.168.0.0/16 } return
    nft add rule $NFT_TABLE $CHAIN_OUT meta l4proto { tcp, udp } meta mark set $PROXY_FWMARK accept

    # 8. Policy Routing
    ip route show table $TABLE_ID | grep -q "local default" || \
        ip route add local default dev lo table $TABLE_ID
    ip rule show table $TABLE_ID | grep -q "fwmark $PROXY_FWMARK" || \
        ip rule add fwmark $PROXY_FWMARK lookup $TABLE_ID pref 9000
        
    if [ -f /proc/net/if_inet6 ]; then
        ip -6 route show table $TABLE_ID | grep -q "local default" || \
            ip -6 route add local default dev lo table $TABLE_ID 2>/dev/null
        ip -6 rule show table $TABLE_ID | grep -q "fwmark $PROXY_FWMARK" || \
            ip -6 rule add fwmark $PROXY_FWMARK lookup $TABLE_ID pref 9000 2>/dev/null
    fi

    log "Rules loaded."
}

clear_nft_rules() {
    NFT_TABLE="inet fw4"
    # Clean Hooks
    for h in $(nft --handle list chain $NFT_TABLE mangle_prerouting 2>/dev/null | awk '/Singbox_Pre_Hook/ {for(i=1;i<=NF;i++) if($i=="handle") print $(i+1)}'); do
        nft delete rule $NFT_TABLE mangle_prerouting handle $h 2>/dev/null
    done
    for h in $(nft --handle list chain $NFT_TABLE mangle_output 2>/dev/null | awk '/Singbox_Out_Hook/ {for(i=1;i<=NF;i++) if($i=="handle") print $(i+1)}'); do
        nft delete rule $NFT_TABLE mangle_output handle $h 2>/dev/null
    done

    # Clean Chains
    nft flush chain $NFT_TABLE $CHAIN_PRE 2>/dev/null
    nft delete chain $NFT_TABLE $CHAIN_PRE 2>/dev/null
    nft flush chain $NFT_TABLE $CHAIN_OUT 2>/dev/null
    nft delete chain $NFT_TABLE $CHAIN_OUT 2>/dev/null

    # Clean Routing
    case "$PROXY_FWMARK" in
        0x*) FWMARK_DEC=$((PROXY_FWMARK)) ;;
        *) FWMARK_DEC=$PROXY_FWMARK ;;
    esac

    while ip rule show | grep -q "fwmark $PROXY_FWMARK"; do
        ip rule del fwmark $FWMARK_DEC table $TABLE_ID 2>/dev/null
    done
    ip route flush table $TABLE_ID 2>/dev/null

    if [ -f /proc/net/if_inet6 ]; then
        while ip -6 rule show | grep -q "fwmark $PROXY_FWMARK"; do
            ip -6 rule del fwmark $FWMARK_DEC table $TABLE_ID 2>/dev/null
        done
        ip -6 route flush table $TABLE_ID 2>/dev/null
    fi
    log "Rules cleared."
}

start_service() {
    sleep 5
    load_modules
    load_nft_rules
}

stop_service() {
    clear_nft_rules
}